# Introdução

## Dados

Muito foi dito sobre dados, que estes são abundantes e estão em constante crescimento, porém o que são dados ? 

Bem esta pergunta possui diversas respostas, isto porque há várias definições para dados, aqui iremos assumir que dados são "Qualquer coisa registrada com o propósito de posteriormente ser analisado" - Rafael Santos.

### Formatos de dados

Como já citado, existem muitos dados disponíveis, estes vindos das mais diversas fontes e formatos, e boa parte dos desafios na análise de dados está vinculada ao formato com que o dados está disponível, isto porque dependendo do formato, existem etapas de organização que devem ser aplicada nos dados.

Nos subtópicos abaixo, serão descritos os principais formatos de dados e alguns exemplos de cada um destes.

#### Dados estruturados

#### Dados semi-estruturados

#### Dados não estruturados

## O que é análise de dados

### Etapas da análise de dados

## Diferenças entre análise de dados e ciência de dados

<!--chapter:end:01-intro.Rmd-->

# Introdução ao R

## Definição de variáveis

### Tipos primitivos
```{r}
  a <- 7L
  b = 14.01
  42 -> c
  k <- FALSE
  g <- 12i # tipo complexo*
  couse <- 'cool'
  
  
  # Para ver inspecionar o valor das variáveis
  print(a)
  b
  cat(c)
  
  # Para ver as classes[1]
  class(a)
  class(b)
  class(c)
  class(k)
  class(couse)
  
  # Para remove-las
  rm(a)
  
```

1.2 Tipos de dados estruturados
```{r}
  # Vetores[2]
  vetor_boleano <- c(FALSE, TRUE, TRUE, FALSE)
  vetor_numerico <- c(3.14, 6.28, 2.3)
  vetor_char <- c('ola', 'pessoal', 'xd')
  v01 <- 1:4
  v02 <- 84:76
  v03 <- seq(from=1, to=10)
  v06 <- rep('DATA SCIENCE', 50)
  v08 <- paste("A", 'B', 'C') 
  v11 <- paste0("EX_", 1:5)
  
  # Podemos misturar tudo
  vetor_misturado <- c("sou legal", FALSE, 21)
  # Vetor atomico tem um único tipo, então se misturarmos, vai converter para o tipo mais forte:
  #1 - character
  #2 - complex
  #3 - numeric
  #4 - integerc
  #5- logical
  # Vetor misturado será convertido em qual tipo?
  
  # Conferirndo a variável e tamanho
  is.atomic(vetor_boleano)
  is.list(vetor_boleano)
  length(vetor_boleano)
  
  # Lista
  lista_boleano <- list(FALSE, TRUE, TRUE, FALSE)
  lista_inteiro <- list(12L, 10L, 7L)
  lista_misturada <- list(FALSE, 12L, 't', 2i)
  
  # Conferindo o tamanho da lista
  is.list(lista_boleano)
  is.recursive(lista_boleano)
  is.atomic(lista_boleano)
  is.list(lista_inteiro)
  
  
  # Array
  a <- array(c('green','yellow'),dim = c(3,3,2)); a
  
  class(a)
  typeof(a)
  is.atomic(a)
  # Por que não é um vetor?
  is.vector(a)
  is.list(a)
  
  
  # Matriz
   m2 <- matrix(data = c(1:25, rep("legal", 5)), nrow = 5, ncol=6)
   
   is.matrix(m2)
   is.array(m2)
   
   m2[5,6]

```

1.3 DataFrame

```{r}
   # DataFrame[3]
   data_frame <- data.frame(Risco=c(FALSE,FALSE, FALSE, FALSE,TRUE), Animal=c("Cachorro", "Gato", "Capivara", "Girafa", "Macaco"), Periculosidade=c(200, 400, 0, 7, 1000))
  
  # Para ver o tamanho
  length(data_frame)
  
  # Podemos acessar os valores individuais usando o '$'
  data_frame$Animal
  
  # Acessando os valores por indices
  data_frame[,2]
  data_frame[2,]
  data_frame[3,2]
  
  
  # Visualização das lihas iniciais
  head(data_frame)
  # Visualização das linhas finais
  tail(data_frame)
  
  # Nome das colunas
  colnames(data_frame)
  # Nome das linhas
  rownames(data_frame)
  
  # Quantidade de colunas
  ncol(data_frame)
  # Quantidade de linhas
  nrow(data_frame)
  
  # Podemos observar a estrutura
  str(data_frame)
  
  # Algumas estatísticas básicas 
  summary(data_frame)
```


2. Operações Básicas

2.1 Dicas úteis
```{r, eval=FALSE}
  # Para usar algum pacote
  library(tidyverse)

  # Para procurar por um pacote
  ??ggsom

  # Para instalar algum pacote que esteja no CRAN [4]
  #install.packages("meupacotefavorite")

  # Para ler sobre alguma função
  ?sum()
  
  # Para verificar seu diretório atual
  getwd() 
  
  # Para definir um novo diretório
  setwd("~/R/ggsom/")
  
  # Para ler conjunto de dados
  df <- read.csv2("~/Dados/pesquisa_google_trend/convolutional_neural_networks.csv", 
            header = TRUE, sep = ",")
  
  # Dependendo do tamanho do dataset, vale a pena usar fread() ou read_csv()
```


2.2 Estatisca básica
```{r}
  # Vamos usar o dado do filme Star Wars do pacote dplyr*
  suppressMessages(library(dplyr))
  starwars <- dplyr::starwars
  
  # Desse modo o dataset é carregado no nosso ambiente, use ls()
  data(starwars)
  
  # Vamos visualizar o dado
  dplyr::glimpse(starwars)
  
  # Vamos ver a média de ano de nascimento
  mean(starwars$birth_year)
  
  # oops... - Observe que o NA atrapalha nossa média,vamos remove-lo
  mean(starwars$birth_year, na.rm = TRUE)
  
  
  # Podemos procurar pela menor data de nascimento
  min(starwars$birth_year, na.rm = TRUE)
  
  # Pelo máximo também
  max(starwars$birth_year, na.rm = TRUE)
  
  # Desvio padrão 
  sd(starwars$birth_year, na.rm = TRUE)
```

3. Os ifs da vida...
```{r, eval=FALSE}
  
  if(starwars$name == "Luke Skywalker"){
    "Faz cara de vilão"
  } else {
    "Faz cara de bonzinho"
  }
  # hackezinho rápido
  vilao <- ifelse(starwars$name == "Luke Skywalker",
         TRUE, FALSE)
  
  # Pense em vetor...
  starwars$name[vilao]
  
  # Foreach
  for(i in starwars$name){
    print(i)
  }
  
  # Um For pouco mais rápido[5]
  for(i in seq_along(starwars$name)){
    print(starwars$name[i])
  }
  # Usando map do pacote purr
  library(purrr)
  purrr::map_chr(starwars$name, print)

```

## Para saber mais

[Números complexos - 1](!https://stat.ethz.ch/R-manual/R-devel/library/base/html/complex.html)

[Tipos númericos em R - 2](!http://uc-r.github.io/integer_double/)

[Diferença entre lista e vetor - 3](!https://www.burns-stat.com/documents/tutorials/impatient-r/)

[CRAN - 4](!https://cran.r-project.org/doc/FAQ/R-FAQ.html#Introduction)

[R eficiente - 5](!https://csgillespie.github.io/efficientR/)


## Materias utilizados como base
[Rafael Santos](!https://github.com/rafaeldcsantos/CAP-394)

- José Roberto M. Garcia


 













<!--chapter:end:02-rlang.Rmd-->

# Introdução ao Python `r emo::ji("rocket")`

Python é uma linguagem multiparadigma, com uma sintaxe muito simples que permite ao programador focar no problema e deixar de lado questões da linguagem. 
Esta é uma linguagem amplamente utilizada em diversos áreas, por conta principalmente das milhares de bibliotecas que a linguagem possui, todas elas distribuidas pela comunidade incrível que a linguagem possui `r emo::ji("heart")`

Neste introdução, o foco será a aplicação da linguagem Python na manipulação e tratamento de dados, utilizando como base as bibliotecas Pandas e ao Matplotlib.

Você pode estar se perguntando o motivo da utilização destas bibliotecas, e a respostas é bem simples, Python é uma linguagem para uso geral, assim, suas funções nativas não tem foco em uma função específica, como ocorre em linguagem como R, que já tem um foco em uma área específica (No caso do R, em análises estatísticas, como descrito no capítulo 2 deste material).

Vamos começar !

## Introdução ao Pandas `r emo::ji("panda_face")`

Como forma de iniciar, vamos começar entendendo o que é a biblioteca Pandas e qual seu objetivo geral, para isto, vejamos a definição feita pelo próprio site do projeto.

> pandas é uma biblioteca open source, licenciada pelo BSD, que fornece estruturas de dados de alto desempenho e fáceis de usar e ferramentas de análise de dados para a linguagem de programação Python.

Veja então que, tudo o que é necessário para a realização da maioria dos casos de análise de dados utilizando a linguagem Python, irão, bem provavelmente, trabalhar com esta biblioteca.

Para que se tenha uma ideia, o pandas pode ser aplicado em análises envolvendo:

- Finanças;
- Análise estatística;
- Ciência social;
- Além de diversas outras áreas de ciências e engenharia.

Isto tudo, por contar com diversas funções e estruturas de dados que facilitam os processos de análise, por falar nestas funções e estruturas, no próximo tópico, vamos discutir um pouco mais sobre as principais presentes no pandas. 

## Estruturas de dados

As duas principais estruturas de dados presentes no pandas são:

- Series;
- DataFrames.

Vejamos as principais características de cada uma delas

### Series

As `Series` são estruturas de dados unidimensionais, que contam com diversos métodos para a manipulação de dados.
Pode-se entender que as `Series` são estruturas de dados simples, assim como as listas padrões da linguagem Python, com uma pequena diferença, para cada item dentro de uma `Series` tem-se indices, estes podendo ser valores numéricos ou texto.

Vamos começar a utilização, para facilitar o entendimento.

```{r}
# Estes comandos não devem ser executados em seu terminal
library(reticulate) 
use_python("/home/felipe/anaconda3/bin/python")
```

Para iniciar, vamos criar um simples `Series` e colocar dentro de uma variável. Para isto, importando a biblioteca pandas, e passamos para ela o 'apelido' de `pd`.

Em seguida, criar uma `Series` simples, passando como parâmetro de entrada uma lista com três valores, veja:

```{python}
import pandas as pd

s = pd.Series([1, 2, 3]); print(s)
```

É interessante notar que, cada uma das linhas, tem associado um index (Pode ser visto do lado esquerdo dos valores), e isto permite a recuperação dos valores através destes index. Você pode fazer uma analogia a forma com que você recupera os valores em um dicionário em Python, a diferença aqui é que, esta é uma estrutura de dados de alto desempenho, além de que, estas estruturas são otimizadas para fazer a melhor utilização de memória possível.

```{python}
print(s[0]) # Recupera o valor do index com nome 0
```

Por falar em dicionários, estes podem ser facilmente transformados em `Series`, veja:

```{python}
dicto = {
  'faculdade': 'Fatec',
  'nota': 10 
}

dicto_s = pd.Series(dicto); print(dicto_s)
```

Após a conversão, o uso é basicamente o mesmo do dicionário, porém com os benefícios já citados. Além do que já foi dito sobre os `Series`, é importante lembrar que, estas estruturas de dados possuem diversos métodos para facilitar a manipulação e entendimento dos dados, vamos a alguns destes métodos

Caso queira-se uma rápida descrição de seus dados, é possível obter um resumo estatístico

```{python}
data = pd.Series([1, 2, 3, 4, 5])

print(data.describe())
```

Este tipo de comando pode te ajudar a entender os dados que você está analisando.

Além disto, você pode ter necessidades como buscas dentro do conjunto de dados, existem diversas maneiras de fazer isto com pandas, mas uma forma simples e intuitiva é a utilização de indexação booleana, onde basicamente uma expressão lógica é passada como ponto para indexação.

```{python}
data_m_tres = data[data > 3] # Devolve todos os valores dentro da Serie que são maiores que 3
print(data_m_tres)
```

É possível ainda unir expressões

```{python}
intervalo = data[(data >= 2 & data =< 4)] # 2 >= data <= 4 
print(intervalo)
```

### Dataframes

## Introdução ao Matplotlib `r emo::ji("bar_chart")`

<!--chapter:end:03-python.Rmd-->

