[
["introducao.html", "1 Introdução 1.1 Dados 1.2 O que é análise de dados 1.3 Diferenças entre análise de dados e ciência de dados", " 1 Introdução A análise de dados é uma das atividades mais interessantes da atualidade, com ela é possível monitorar o governo, fazer empresas de sucesso e produtos que atendam a real necessidade de seus clientes, e o mais importante, com ela é possível saciar nossa curiosidade. Isto porque com a quantidade de dados disponível, podemos literalmente, saber sobre tudo, apenas realizando análises. Mas para fazer estas análises é preciso dominar metodologias e tecnologias de análise, assim, este trabalho tem como objetivo apresentar, de forma introdutória, as principais tecnologias para análise de dados, as linguagens de programação R e Python. 1.1 Dados Muito foi dito sobre dados, que estes são abundantes e estão em constante crescimento, porém o que são dados ? Bem esta pergunta possui diversas respostas, isto porque há várias definições para dados, aqui iremos assumir que dados são “Qualquer coisa registrada com o propósito de posteriormente ser analisado” - Rafael Santos. 1.1.1 Formatos de dados Como já citado, existem muitos dados disponíveis, estes vindos das mais diversas fontes e formatos, e boa parte dos desafios na análise de dados está vinculada ao formato com que o dados está disponível, isto porque dependendo do formato, existem etapas de organização que devem ser aplicada nos dados. Nos subtópicos abaixo, serão descritos os principais formatos de dados e alguns exemplos de cada um destes. 1.1.1.1 Dados estruturados 1.1.1.2 Dados semi-estruturados 1.1.1.3 Dados não estruturados 1.2 O que é análise de dados 1.2.1 Etapas da análise de dados 1.3 Diferenças entre análise de dados e ciência de dados "],
["introducao-ao-r.html", "2 Introdução ao R 2.1 Definição de variáveis 2.2 Para saber mais 2.3 Materias utilizados como base", " 2 Introdução ao R 2.1 Definição de variáveis 2.1.1 Tipos primitivos a &lt;- 7L b = 14.01 42 -&gt; c k &lt;- FALSE g &lt;- 12i # tipo complexo* couse &lt;- &#39;cool&#39; # Para ver inspecionar o valor das variáveis print(a) ## [1] 7 b ## [1] 14.01 cat(c) ## 42 # Para ver as classes[1] class(a) ## [1] &quot;integer&quot; class(b) ## [1] &quot;numeric&quot; class(c) ## [1] &quot;numeric&quot; class(k) ## [1] &quot;logical&quot; class(couse) ## [1] &quot;character&quot; # Para remove-las rm(a) 1.2 Tipos de dados estruturados # Vetores[2] vetor_boleano &lt;- c(FALSE, TRUE, TRUE, FALSE) vetor_numerico &lt;- c(3.14, 6.28, 2.3) vetor_char &lt;- c(&#39;ola&#39;, &#39;pessoal&#39;, &#39;xd&#39;) v01 &lt;- 1:4 v02 &lt;- 84:76 v03 &lt;- seq(from=1, to=10) v06 &lt;- rep(&#39;DATA SCIENCE&#39;, 50) v08 &lt;- paste(&quot;A&quot;, &#39;B&#39;, &#39;C&#39;) v11 &lt;- paste0(&quot;EX_&quot;, 1:5) # Podemos misturar tudo vetor_misturado &lt;- c(&quot;sou legal&quot;, FALSE, 21) # Vetor atomico tem um único tipo, então se misturarmos, vai converter para o tipo mais forte: #1 - character #2 - complex #3 - numeric #4 - integerc #5- logical # Vetor misturado será convertido em qual tipo? # Conferirndo a variável e tamanho is.atomic(vetor_boleano) ## [1] TRUE is.list(vetor_boleano) ## [1] FALSE length(vetor_boleano) ## [1] 4 # Lista lista_boleano &lt;- list(FALSE, TRUE, TRUE, FALSE) lista_inteiro &lt;- list(12L, 10L, 7L) lista_misturada &lt;- list(FALSE, 12L, &#39;t&#39;, 2i) # Conferindo o tamanho da lista is.list(lista_boleano) ## [1] TRUE is.recursive(lista_boleano) ## [1] TRUE is.atomic(lista_boleano) ## [1] FALSE is.list(lista_inteiro) ## [1] TRUE # Array a &lt;- array(c(&#39;green&#39;,&#39;yellow&#39;),dim = c(3,3,2)); a ## , , 1 ## ## [,1] [,2] [,3] ## [1,] &quot;green&quot; &quot;yellow&quot; &quot;green&quot; ## [2,] &quot;yellow&quot; &quot;green&quot; &quot;yellow&quot; ## [3,] &quot;green&quot; &quot;yellow&quot; &quot;green&quot; ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] &quot;yellow&quot; &quot;green&quot; &quot;yellow&quot; ## [2,] &quot;green&quot; &quot;yellow&quot; &quot;green&quot; ## [3,] &quot;yellow&quot; &quot;green&quot; &quot;yellow&quot; class(a) ## [1] &quot;array&quot; typeof(a) ## [1] &quot;character&quot; is.atomic(a) ## [1] TRUE # Por que não é um vetor? is.vector(a) ## [1] FALSE is.list(a) ## [1] FALSE # Matriz m2 &lt;- matrix(data = c(1:25, rep(&quot;legal&quot;, 5)), nrow = 5, ncol=6) is.matrix(m2) ## [1] TRUE is.array(m2) ## [1] TRUE m2[5,6] ## [1] &quot;legal&quot; 1.3 DataFrame # DataFrame[3] data_frame &lt;- data.frame(Risco=c(FALSE,FALSE, FALSE, FALSE,TRUE), Animal=c(&quot;Cachorro&quot;, &quot;Gato&quot;, &quot;Capivara&quot;, &quot;Girafa&quot;, &quot;Macaco&quot;), Periculosidade=c(200, 400, 0, 7, 1000)) # Para ver o tamanho length(data_frame) ## [1] 3 # Podemos acessar os valores individuais usando o &#39;$&#39; data_frame$Animal ## [1] Cachorro Gato Capivara Girafa Macaco ## Levels: Cachorro Capivara Gato Girafa Macaco # Acessando os valores por indices data_frame[,2] ## [1] Cachorro Gato Capivara Girafa Macaco ## Levels: Cachorro Capivara Gato Girafa Macaco data_frame[2,] ## Risco Animal Periculosidade ## 2 FALSE Gato 400 data_frame[3,2] ## [1] Capivara ## Levels: Cachorro Capivara Gato Girafa Macaco # Visualização das lihas iniciais head(data_frame) ## Risco Animal Periculosidade ## 1 FALSE Cachorro 200 ## 2 FALSE Gato 400 ## 3 FALSE Capivara 0 ## 4 FALSE Girafa 7 ## 5 TRUE Macaco 1000 # Visualização das linhas finais tail(data_frame) ## Risco Animal Periculosidade ## 1 FALSE Cachorro 200 ## 2 FALSE Gato 400 ## 3 FALSE Capivara 0 ## 4 FALSE Girafa 7 ## 5 TRUE Macaco 1000 # Nome das colunas colnames(data_frame) ## [1] &quot;Risco&quot; &quot;Animal&quot; &quot;Periculosidade&quot; # Nome das linhas rownames(data_frame) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; # Quantidade de colunas ncol(data_frame) ## [1] 3 # Quantidade de linhas nrow(data_frame) ## [1] 5 # Podemos observar a estrutura str(data_frame) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ Risco : logi FALSE FALSE FALSE FALSE TRUE ## $ Animal : Factor w/ 5 levels &quot;Cachorro&quot;,&quot;Capivara&quot;,..: 1 3 2 4 5 ## $ Periculosidade: num 200 400 0 7 1000 # Algumas estatísticas básicas summary(data_frame) ## Risco Animal Periculosidade ## Mode :logical Cachorro:1 Min. : 0.0 ## FALSE:4 Capivara:1 1st Qu.: 7.0 ## TRUE :1 Gato :1 Median : 200.0 ## NA&#39;s :0 Girafa :1 Mean : 321.4 ## Macaco :1 3rd Qu.: 400.0 ## Max. :1000.0 Operações Básicas 2.1 Dicas úteis # Para usar algum pacote library(tidyverse) # Para procurar por um pacote ??ggsom # Para instalar algum pacote que esteja no CRAN [4] #install.packages(&quot;meupacotefavorite&quot;) # Para ler sobre alguma função ?sum() # Para verificar seu diretório atual getwd() # Para definir um novo diretório setwd(&quot;~/R/ggsom/&quot;) # Para ler conjunto de dados df &lt;- read.csv2(&quot;~/Dados/pesquisa_google_trend/convolutional_neural_networks.csv&quot;, header = TRUE, sep = &quot;,&quot;) # Dependendo do tamanho do dataset, vale a pena usar fread() ou read_csv() 2.2 Estatisca básica # Vamos usar o dado do filme Star Wars do pacote dplyr* suppressMessages(library(dplyr)) starwars &lt;- dplyr::starwars # Desse modo o dataset é carregado no nosso ambiente, use ls() data(starwars) # Vamos visualizar o dado dplyr::glimpse(starwars) ## Observations: 87 ## Variables: 13 ## $ name &lt;chr&gt; &quot;Luke Skywalker&quot;, &quot;C-3PO&quot;, &quot;R2-D2&quot;, &quot;Darth Vader&quot;, ... ## $ height &lt;int&gt; 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188... ## $ mass &lt;dbl&gt; 77.0, 75.0, 32.0, 136.0, 49.0, 120.0, 75.0, 32.0, 8... ## $ hair_color &lt;chr&gt; &quot;blond&quot;, NA, NA, &quot;none&quot;, &quot;brown&quot;, &quot;brown, grey&quot;, &quot;b... ## $ skin_color &lt;chr&gt; &quot;fair&quot;, &quot;gold&quot;, &quot;white, blue&quot;, &quot;white&quot;, &quot;light&quot;, &quot;l... ## $ eye_color &lt;chr&gt; &quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;brown&quot;, &quot;blue&quot;,... ## $ birth_year &lt;dbl&gt; 19.0, 112.0, 33.0, 41.9, 19.0, 52.0, 47.0, NA, 24.0... ## $ gender &lt;chr&gt; &quot;male&quot;, NA, NA, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,... ## $ homeworld &lt;chr&gt; &quot;Tatooine&quot;, &quot;Tatooine&quot;, &quot;Naboo&quot;, &quot;Tatooine&quot;, &quot;Alder... ## $ species &lt;chr&gt; &quot;Human&quot;, &quot;Droid&quot;, &quot;Droid&quot;, &quot;Human&quot;, &quot;Human&quot;, &quot;Human... ## $ films &lt;list&gt; [&lt;&quot;Revenge of the Sith&quot;, &quot;Return of the Jedi&quot;, &quot;Th... ## $ vehicles &lt;list&gt; [&lt;&quot;Snowspeeder&quot;, &quot;Imperial Speeder Bike&quot;&gt;, &lt;&gt;, &lt;&gt;,... ## $ starships &lt;list&gt; [&lt;&quot;X-wing&quot;, &quot;Imperial shuttle&quot;&gt;, &lt;&gt;, &lt;&gt;, &quot;TIE Adva... # Vamos ver a média de ano de nascimento mean(starwars$birth_year) ## [1] NA # oops... - Observe que o NA atrapalha nossa média,vamos remove-lo mean(starwars$birth_year, na.rm = TRUE) ## [1] 87.56512 # Podemos procurar pela menor data de nascimento min(starwars$birth_year, na.rm = TRUE) ## [1] 8 # Pelo máximo também max(starwars$birth_year, na.rm = TRUE) ## [1] 896 # Desvio padrão sd(starwars$birth_year, na.rm = TRUE) ## [1] 154.6914 Os ifs da vida… if(starwars$name == &quot;Luke Skywalker&quot;){ &quot;Faz cara de vilão&quot; } else { &quot;Faz cara de bonzinho&quot; } # hackezinho rápido vilao &lt;- ifelse(starwars$name == &quot;Luke Skywalker&quot;, TRUE, FALSE) # Pense em vetor... starwars$name[vilao] # Foreach for(i in starwars$name){ print(i) } # Um For pouco mais rápido[5] for(i in seq_along(starwars$name)){ print(starwars$name[i]) } # Usando map do pacote purr library(purrr) purrr::map_chr(starwars$name, print) 2.2 Para saber mais Números complexos - 1 Tipos númericos em R - 2 Diferença entre lista e vetor - 3 CRAN - 4 R eficiente - 5 2.3 Materias utilizados como base Rafael Santos José Roberto M. Garcia "],
["introducao-ao-python.html", "3 Introdução ao Python 🚀 3.1 Introdução ao Pandas 🐼 3.2 Estruturas de dados 3.3 Introdução ao Matplotlib 📊", " 3 Introdução ao Python 🚀 Python é uma linguagem multiparadigma, com uma sintaxe muito simples que permite ao programador focar no problema e deixar de lado questões da linguagem. Esta é uma linguagem amplamente utilizada em diversos áreas, por conta principalmente das milhares de bibliotecas que a linguagem possui, todas elas distribuidas pela comunidade incrível que a linguagem possui ❤️ Neste introdução, o foco será a aplicação da linguagem Python na manipulação e tratamento de dados, utilizando como base as bibliotecas Pandas e ao Matplotlib. Você pode estar se perguntando o motivo da utilização destas bibliotecas, e a respostas é bem simples, Python é uma linguagem para uso geral, assim, suas funções nativas não tem foco em uma função específica, como ocorre em linguagem como R, que já tem um foco em uma área específica (No caso do R, em análises estatísticas, como descrito no capítulo 2 deste material). Vamos começar ! 3.1 Introdução ao Pandas 🐼 Como forma de iniciar, vamos começar entendendo o que é a biblioteca Pandas e qual seu objetivo geral, para isto, vejamos a definição feita pelo próprio site do projeto. pandas é uma biblioteca open source, licenciada pelo BSD, que fornece estruturas de dados de alto desempenho e fáceis de usar e ferramentas de análise de dados para a linguagem de programação Python. Veja então que, tudo o que é necessário para a realização da maioria dos casos de análise de dados utilizando a linguagem Python, irão, bem provavelmente, trabalhar com esta biblioteca. Para que se tenha uma ideia, o pandas pode ser aplicado em análises envolvendo: Finanças; Análise estatística; Ciência social; Além de diversas outras áreas de ciências e engenharia. Isto tudo, por contar com diversas funções e estruturas de dados que facilitam os processos de análise, por falar nestas funções e estruturas, no próximo tópico, vamos discutir um pouco mais sobre as principais presentes no pandas. 3.2 Estruturas de dados As duas principais estruturas de dados presentes no pandas são: Series; DataFrames. Nos subtópicos abaixo vamos ver as características de cada uma destas estruturas, e em seguida, veremos alguns utilitários para leitura dos dados com Pandas. 3.2.1 Series As Series são estruturas de dados unidimensionais, que contam com diversos métodos para a manipulação de dados. Pode-se entender que as Series são estruturas de dados simples, assim como as listas padrões da linguagem Python, com uma pequena diferença, para cada item dentro de uma Series tem-se indices, estes podendo ser valores numéricos ou texto. Vamos começar a utilização, para facilitar o entendimento. # Estes comandos não devem ser executados em seu terminal library(reticulate) use_python(&quot;/home/felipe/anaconda3/bin/python&quot;) Para iniciar, vamos criar um simples Series e colocar dentro de uma variável. Para isto, importando a biblioteca pandas, e passamos para ela o ‘apelido’ de pd. Em seguida, criar uma Series simples, passando como parâmetro de entrada uma lista com três valores, veja: import pandas as pd s = pd.Series([1, 2, 3]); print(s) ## 0 1 ## 1 2 ## 2 3 ## dtype: int64 É interessante notar que, cada uma das linhas, tem associado um index (Pode ser visto do lado esquerdo dos valores), e isto permite a recuperação dos valores através destes index. Você pode fazer uma analogia a forma com que você recupera os valores em um dicionário em Python, a diferença aqui é que, esta é uma estrutura de dados de alto desempenho, além de que, estas estruturas são otimizadas para fazer a melhor utilização de memória possível. print(s[0]) # Recupera o valor do index com nome 0 ## 1 Por falar em dicionários, estes podem ser facilmente transformados em Series, veja: dicto = { &#39;faculdade&#39;: &#39;Fatec&#39;, &#39;nota&#39;: 10 } dicto_s = pd.Series(dicto); print(dicto_s) ## faculdade Fatec ## nota 10 ## dtype: object Após a conversão, o uso é basicamente o mesmo do dicionário, porém com os benefícios já citados. Além do que já foi dito sobre os Series, é importante lembrar que, estas estruturas de dados possuem diversos métodos para facilitar a manipulação e entendimento dos dados, vamos a alguns destes métodos Caso queira-se uma rápida descrição de seus dados, é possível obter um resumo estatístico data = pd.Series([1, 2, 3, 4, 5]) print(data.describe()) ## count 5.000000 ## mean 3.000000 ## std 1.581139 ## min 1.000000 ## 25% 2.000000 ## 50% 3.000000 ## 75% 4.000000 ## max 5.000000 ## dtype: float64 Este tipo de comando pode te ajudar a entender os dados que você está analisando. Além disto, você pode ter necessidades como buscas dentro do conjunto de dados, existem diversas maneiras de fazer isto com pandas, mas uma forma simples e intuitiva é a utilização de indexação booleana, onde basicamente uma expressão lógica é passada como ponto para indexação. data_m_tres = data[data &gt; 3] # Devolve todos os valores dentro da Serie que são maiores que 3 print(data_m_tres) ## 3 4 ## 4 5 ## dtype: int64 Caso os valores das variáveis sejam string, também é possível realizar buscas, utilizando a mesma técnica. faculdade = dicto_s[dicto_s == &#39;Fatec&#39;] # Recupera o campo que tem o valor &#39;Fatec&#39; print(faculdade) ## faculdade Fatec ## dtype: object Porém, como citado lá no início deste tutorial, as Series são estruturas unidimensionais, o que significa que não poderemos ter matrizes dentro das Series, caso tentarmos fazer a inserção de uma matriz, ele irá aceitar, porém, fará o tratamento dos dados como se fossem diveras listas separadas dentro da Series, veja: matriz = pd.Series([[1, 2, 3], [4, 5, 6]]) print(matriz) ## 0 [1, 2, 3] ## 1 [4, 5, 6] ## dtype: object Percebeu ? Para estes casos, faz-se necessário o uso de uma outra estrutura de dados, o DataFrame, que vamos tratar no próximo capítulo. 3.2.2 Dataframes Agora que você já conhece como as Series funcionam, vamos apresentar a você o DataFrame, que difere das Series por serem multidimensionais, ou seja, aqui temos matrizes 🌈 Mas por esta simples diferença, a manipulação dos DataFrames acabam sendo diferentes, não nos métodos, que em boa parte dos casos será os mesmos já apresentados, e sim, na maneira de pensar na manipulação, isto porque, trabalhar com multiplas linhas e colunas de uma única vez, pode tornar sua análise diferente. Além disto, no caso do pandas, boa parte dos métodos de leitura de dados, já retornam por padrão o DataFrame (Os métodos de leitura serão explicados mais abaixo). Vejamos algumas características bacanas dos DataFrames matriz = pd.DataFrame([[1, 2, 3], [4, 5, 6]]) print(matriz) ## 0 1 2 ## 0 1 2 3 ## 1 4 5 6 Veja que, da mesma forma que as Series, os DataFrames tem o index que pode ser nomeado, e além destes, as colunas também podem ser nomeadas. tabela = pd.DataFrame([[.9, .8, .7], [.4, .5, .7]], columns = [&#39;primeiro&#39;, &#39;segundo&#39;, &#39;terceiro&#39;], index = [&#39;zero&#39;, &#39;um&#39;]) print(tabela) ## primeiro segundo terceiro ## zero 0.9 0.8 0.7 ## um 0.4 0.5 0.7 E a recuperação tanto das linhas quanto das colunas pode ser feita utilizando a ideia da recuperação em dicionários de Python, como citado anteriormente. # Recuperando coluna coluna = tabela[&#39;primeiro&#39;] print(coluna) ## zero 0.9 ## um 0.4 ## Name: primeiro, dtype: float64 # Recuperando linha linha = tabela.loc[&#39;zero&#39;] print(linha) ## primeiro 0.9 ## segundo 0.8 ## terceiro 0.7 ## Name: zero, dtype: float64 Para a recuperação da linha utilizamos um método do DataFrame, o loc, este permite recuperar uma linha através de seu nome, porém pode-se também recuperar pela posição, utilizando o método iloc. linha_um = tabela.iloc[1] A diferença entre os métodos está justamente no que ele procura, no primeiro, loc, busca-se nomes, e no segundo, iloc, tenta-se recuperar a posição. Quando apresentamos as Series falamos sobre o método describe, ele também está disponível para o DataFrame, porém, caso você queira algum parâmetro estatístico específico, é possível chama-lo através de um método do DataFrame. print(tabela.mean()) # Média ## primeiro 0.65 ## segundo 0.65 ## terceiro 0.70 ## dtype: float64 print(tabela.median()) # Mediana ## primeiro 0.65 ## segundo 0.65 ## terceiro 0.70 ## dtype: float64 Outros métodos úteis podem ser vistos abaixo print(tabela.max()) # Recupera a coluna com maior valor ## primeiro 0.9 ## segundo 0.8 ## terceiro 0.7 ## dtype: float64 print(tabela.min()) # Recupera a coluna com o menor valor ## primeiro 0.4 ## segundo 0.5 ## terceiro 0.7 ## dtype: float64 print(tabela.sum()) # Faz o somatório dos valores de cada linha ## primeiro 1.3 ## segundo 1.3 ## terceiro 1.4 ## dtype: float64 Lembre-se, muitos dos métodos apresentados na seção do DataFrame funcionam nas Series, e o contrátio também é verdadeiro. 3.2.3 Funções de leitura e escrita Além das estruturas de dados poderosas, o pandas também possui funções para leitura e escrita que são APELONAS Para a leitura de csv, podemos utilizar a read_csv df = pd.read_csv(&#39;data/titanic.csv&#39;) # O caminho pode ser diferente eu sua máquina print(df.head()) # Função que demonstra o início do DataFrame carregado ## PassengerId Pclass Name Sex \\ ## 0 892 3 Kelly, Mr. James male ## 1 893 3 Wilkes, Mrs. James (Ellen Needs) female ## 2 894 2 Myles, Mr. Thomas Francis male ## 3 895 3 Wirz, Mr. Albert male ## 4 896 3 Hirvonen, Mrs. Alexander (Helga E Lindqvist) female ## ## Age SibSp Parch Ticket Fare Cabin Embarked ## 0 34.5 0 0 330911 7.8292 NaN Q ## 1 47.0 1 0 363272 7.0000 NaN S ## 2 62.0 0 0 240276 9.6875 NaN Q ## 3 27.0 0 0 315154 8.6625 NaN S ## 4 22.0 1 1 3101298 12.2875 NaN S print(df.tail()) # Função que demonstra o final do DataFrame carregado ## PassengerId Pclass Name Sex Age SibSp \\ ## 413 1305 3 Spector, Mr. Woolf male NaN 0 ## 414 1306 1 Oliva y Ocana, Dona. Fermina female 39.0 0 ## 415 1307 3 Saether, Mr. Simon Sivertsen male 38.5 0 ## 416 1308 3 Ware, Mr. Frederick male NaN 0 ## 417 1309 3 Peter, Master. Michael J male NaN 1 ## ## Parch Ticket Fare Cabin Embarked ## 413 0 A.5. 3236 8.0500 NaN S ## 414 0 PC 17758 108.9000 C105 C ## 415 0 SOTON/O.Q. 3101262 7.2500 NaN S ## 416 0 359309 8.0500 NaN S ## 417 1 2668 22.3583 NaN C Caso você esteja trabalhando com alguma API Rest, você pode fazer com que o json seja transportado para um DataFrame, veja json_frame = pd.read_json(&#39;https://www.reddit.com/r/technology/.json&#39;) print(json_frame.head()) ## data kind ## after t3_9lmhre Listing ## before None Listing ## children [{&#39;kind&#39;: &#39;t3&#39;, &#39;data&#39;: {&#39;approved_at_utc&#39;: No... Listing ## dist 27 Listing ## modhash Listing print(json_frame.columns) # Recupera as colunas do DataFrame ## Index([&#39;data&#39;, &#39;kind&#39;], dtype=&#39;object&#39;) Da mesma forma que a leitura, a escrita é extremamente fácil. Para salvar um CSV, ou um JSON, basta utilizar os métodos to_csv e to_json, presentes dentro do DataFrame. df.to_csv(&#39;nome_do_csv.csv&#39;) # Salva o CSV df.to_json(&#39;nome_do_json.json&#39;) # Salva o JSON Viu ? É tudo muito simples e direto, o que te permite focar em sua análise, e deixar de lado problemas com sintaxe 🗽, mas, após a sua análise, é importante apresentar seus dados, para isto, vamos aprender a utilizar a biblioteca matplotlib para fazer plots e visualizar seus dados. 3.3 Introdução ao Matplotlib 📊 Como citado no capítulo anterior, a visualização e apresentação de seus dados é importante, tanto para apresentar o que você analisou, quanto para você mesmo, entender seus dados. Existem diversos tipos de dados, aqui vamos apresentar alguns dos principais tipos de gráficos, e para isto vamos utilizar a biblioteca Matplotlib, que foi criada especialmente para a visualização de dados. "]
]
